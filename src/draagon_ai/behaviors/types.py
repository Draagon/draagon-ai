"""Core type definitions for the behavior system.

Behaviors are pluggable modules that define what an agent CAN DO.
They are data structures (not code) that can be serialized, tested,
and evolved.
"""

from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any


class BehaviorTier(Enum):
    """Behavior origin and trust level."""

    CORE = "core"  # Built into draagon-ai, heavily tested
    ADDON = "addon"  # Official add-on packages
    APPLICATION = "application"  # Provided by host application
    GENERATED = "generated"  # Auto-generated by Behavior Architect
    EXPERIMENTAL = "experimental"  # Under testing, not production-ready


class BehaviorStatus(Enum):
    """Lifecycle status of a behavior."""

    DRAFT = "draft"  # Being developed
    TESTING = "testing"  # Under automated testing
    STAGING = "staging"  # Shadow mode, tracking but not active
    ACTIVE = "active"  # Production ready
    DEPRECATED = "deprecated"  # Being phased out
    RETIRED = "retired"  # No longer available


class ActivationScope(Enum):
    """When this behavior can activate."""

    GLOBAL = "global"  # Always available
    APPLICATION = "application"  # Only in specific applications
    USER = "user"  # Only for specific users
    SESSION = "session"  # Only in specific session contexts
    TRIGGER = "trigger"  # Only when specific triggers match


# =============================================================================
# Action Types
# =============================================================================


@dataclass
class ActionParameter:
    """Parameter definition for an action."""

    name: str
    description: str
    type: str = "string"  # string, int, float, bool, enum, list, dict
    required: bool = True
    default: Any = None
    enum_values: list[str] | None = None
    validation_pattern: str | None = None  # Regex for validation


@dataclass
class ActionExample:
    """Example of action usage for LLM context."""

    user_query: str
    action_call: dict[str, Any]  # {"name": "search_web", "args": {"query": "..."}}
    expected_outcome: str
    is_positive: bool = True  # True = do this, False = don't do this


@dataclass
class ActionMetrics:
    """Metrics for a single action."""

    invocation_count: int = 0
    success_count: int = 0
    failure_count: int = 0
    avg_latency_ms: float = 0.0
    last_invoked: datetime | None = None


@dataclass
class Action:
    """A single action an agent can take within a behavior."""

    name: str  # "search_web", "cast_spell"
    description: str  # Human-readable description

    # Parameters this action accepts
    parameters: dict[str, ActionParameter] = field(default_factory=dict)

    # When this action should be considered
    triggers: list[str] = field(default_factory=list)  # Semantic triggers

    # Examples of this action in use
    examples: list[ActionExample] = field(default_factory=list)

    # Constraints
    requires_confirmation: bool = False
    required_permissions: list[str] = field(default_factory=list)
    cooldown_seconds: int = 0

    # Execution
    handler: str | None = None  # Tool name or handler reference

    # Metadata for evolution
    success_rate: float = 0.0  # Tracked over time
    usage_count: int = 0
    last_used: datetime | None = None


# =============================================================================
# Trigger Types
# =============================================================================


@dataclass
class Trigger:
    """Defines when a behavior should activate."""

    name: str
    description: str

    # Trigger types (OR logic - any match activates)
    semantic_patterns: list[str] = field(default_factory=list)  # LLM evaluates
    keyword_patterns: list[str] = field(default_factory=list)  # Regex patterns
    intent_categories: list[str] = field(default_factory=list)  # From intent classifier
    context_conditions: list[str] = field(default_factory=list)  # e.g., "user.role == 'admin'"

    # Priority for trigger conflicts
    priority: int = 50  # 0-100, higher wins

    # Conditions that PREVENT activation
    exclusion_patterns: list[str] = field(default_factory=list)


# =============================================================================
# Prompt Types
# =============================================================================


@dataclass
class BehaviorPrompts:
    """Prompt templates for a behavior."""

    # Main decision prompt - decides which action to take
    decision_prompt: str

    # Response synthesis - formats the response
    synthesis_prompt: str

    # Optional specialized prompts
    error_recovery_prompt: str | None = None
    confirmation_prompt: str | None = None
    clarification_prompt: str | None = None

    # Prompt versioning for evolution
    version: str = "1.0.0"
    parent_version: str | None = None  # For tracking evolution


# =============================================================================
# Constraint Types
# =============================================================================


@dataclass
class BehaviorConstraints:
    """Rules and limits for a behavior."""

    # Safety constraints
    requires_user_confirmation: list[str] = field(
        default_factory=list
    )  # Actions needing confirm
    blocked_actions: list[str] = field(default_factory=list)  # Never allow these
    rate_limits: dict[str, int] = field(default_factory=dict)  # action -> per_minute

    # Context constraints
    allowed_applications: list[str] | None = None  # None = all
    allowed_users: list[str] | None = None  # None = all
    required_permissions: list[str] = field(default_factory=list)

    # Behavioral constraints (for LLM)
    style_guidelines: list[str] = field(default_factory=list)
    forbidden_topics: list[str] = field(default_factory=list)
    required_disclaimers: list[str] = field(default_factory=list)


# =============================================================================
# Testing Types
# =============================================================================


@dataclass
class BehaviorTestCase:
    """A test case for validating behavior."""

    test_id: str
    name: str
    description: str = ""

    # Input
    user_query: str = ""
    context: dict[str, Any] = field(default_factory=dict)

    # Expected outcomes (any match = pass)
    expected_actions: list[str] = field(default_factory=list)  # Action names
    expected_action_args: dict[str, Any] | None = None  # Specific args
    expected_response_contains: list[str] = field(default_factory=list)
    expected_response_excludes: list[str] = field(default_factory=list)

    # Negative tests
    forbidden_actions: list[str] = field(default_factory=list)

    # Metadata
    priority: str = "medium"  # high, medium, low
    tags: list[str] = field(default_factory=list)


@dataclass
class TestOutcome:
    """Outcome of a single test."""

    test_id: str
    passed: bool
    actual_action: str | None = None
    actual_response: str | None = None
    failure_reason: str | None = None
    latency_ms: float = 0.0


@dataclass
class TestResults:
    """Results from running behavior tests."""

    total_tests: int = 0
    passed: int = 0
    failed: int = 0
    skipped: int = 0

    pass_rate: float = 0.0

    # Detailed results
    test_outcomes: dict[str, TestOutcome] = field(default_factory=dict)

    run_at: datetime = field(default_factory=datetime.now)
    duration_seconds: float = 0.0


# =============================================================================
# Metrics Types
# =============================================================================


@dataclass
class BehaviorMetrics:
    """Tracked metrics for behavior health and evolution."""

    # Usage
    total_activations: int = 0
    total_actions_executed: int = 0

    # Success
    success_rate: float = 0.0  # Actions that succeeded
    user_satisfaction: float = 0.0  # From feedback
    task_completion_rate: float = 0.0  # Did user goal get met?

    # Performance
    avg_latency_ms: float = 0.0
    p95_latency_ms: float = 0.0

    # Issues
    error_count: int = 0
    confusion_count: int = 0  # User had to clarify
    override_count: int = 0  # User corrected the action

    # Evolution
    generations: int = 0  # How many times evolved
    fitness_score: float = 0.0  # Composite fitness
    last_evolved: datetime | None = None

    # Per-action breakdown
    action_metrics: dict[str, ActionMetrics] = field(default_factory=dict)


# =============================================================================
# Main Behavior Type
# =============================================================================


@dataclass
class Behavior:
    """Complete behavior definition.

    A Behavior is a pluggable module that defines what an agent CAN DO.
    It includes:
    - Actions: The specific things this behavior enables
    - Triggers: When this behavior should activate
    - Prompts: How the LLM should reason about this behavior
    - Constraints: Rules and limits
    - Tests: Validation cases
    - Metrics: Performance tracking
    """

    # Identity
    behavior_id: str  # "voice_assistant", "dungeon_master"
    name: str  # Human-readable name
    description: str  # What this behavior enables
    version: str = "1.0.0"

    # Classification
    tier: BehaviorTier = BehaviorTier.APPLICATION
    status: BehaviorStatus = BehaviorStatus.DRAFT

    # Core definition
    actions: list[Action] = field(default_factory=list)
    triggers: list[Trigger] = field(default_factory=list)
    prompts: BehaviorPrompts | None = None
    constraints: BehaviorConstraints = field(default_factory=BehaviorConstraints)

    # Context for LLM
    domain_context: str = ""  # Background knowledge for this domain
    personality_guidance: str = ""  # How personality should manifest

    # Activation rules
    activation_scope: ActivationScope = ActivationScope.GLOBAL
    activation_conditions: list[str] = field(default_factory=list)

    # Dependencies
    requires_behaviors: list[str] = field(default_factory=list)  # Must also be active
    conflicts_with: list[str] = field(default_factory=list)  # Cannot coexist
    extends: str | None = None  # Parent behavior to extend

    # Metadata
    author: str = "system"
    created_at: datetime = field(default_factory=datetime.now)
    updated_at: datetime = field(default_factory=datetime.now)
    metrics: BehaviorMetrics = field(default_factory=BehaviorMetrics)

    # Evolution
    is_evolvable: bool = True  # Can be improved automatically
    evolution_config: dict[str, Any] = field(default_factory=dict)
    parent_behavior_id: str | None = None  # If evolved from another

    # Testing
    test_cases: list[BehaviorTestCase] = field(default_factory=list)
    test_results: TestResults | None = None

    def get_action(self, name: str) -> Action | None:
        """Get an action by name."""
        for action in self.actions:
            if action.name == name:
                return action
        return None

    def get_trigger(self, name: str) -> Trigger | None:
        """Get a trigger by name."""
        for trigger in self.triggers:
            if trigger.name == name:
                return trigger
        return None

    def is_active(self) -> bool:
        """Check if behavior is in active status."""
        return self.status == BehaviorStatus.ACTIVE


# =============================================================================
# Activation Context
# =============================================================================


@dataclass
class ActivationContext:
    """Full context for behavior activation decisions."""

    # Application context
    application_id: str
    application_features: set[str] = field(default_factory=set)

    # User context
    user_id: str = ""
    user_permissions: set[str] = field(default_factory=set)
    user_preferences: dict[str, Any] = field(default_factory=dict)

    # Session context
    session_id: str = ""
    conversation_history: list[dict] = field(default_factory=list)
    active_persona: str | None = None

    # Situational context
    current_query: str = ""
    detected_intent: str | None = None
    detected_entities: list[str] = field(default_factory=list)
    time_of_day: str = "day"  # morning, day, evening, night
    urgency: str = "normal"  # low, normal, high, urgent


@dataclass
class ActiveBehaviorSet:
    """The set of behaviors active for a context."""

    # Primary behavior (handles main decision)
    primary: Behavior | None = None

    # Supporting behaviors (provide additional actions)
    supporting: list[Behavior] = field(default_factory=list)

    # All available actions across active behaviors
    available_actions: list[Action] = field(default_factory=list)

    # Combined constraints
    combined_constraints: BehaviorConstraints = field(default_factory=BehaviorConstraints)

    # Metadata
    activation_reason: str = ""

    def get_all_behaviors(self) -> list[Behavior]:
        """Get all active behaviors."""
        result = []
        if self.primary:
            result.append(self.primary)
        result.extend(self.supporting)
        return result


# =============================================================================
# Evolution Types
# =============================================================================


@dataclass
class EvolutionConfig:
    """Configuration for behavior evolution."""

    # Population settings
    population_size: int = 6
    generations: int = 5

    # Selection
    tournament_size: int = 3
    elitism_count: int = 1

    # Mutation
    mutation_rate: float = 0.3
    crossover_rate: float = 0.5

    # Fitness
    min_test_cases: int = 20
    train_test_split: float = 0.8
    overfitting_threshold: float = 0.1

    # Safety
    require_manual_approval: bool = True
    max_generations_without_improvement: int = 3


@dataclass
class BehaviorEvolutionResult:
    """Result of behavior evolution."""

    original_behavior: Behavior
    evolved_behavior: Behavior
    original_fitness: float
    evolved_fitness: float
    overfitting_gap: float
    generations_run: int
    approved: bool  # Passed overfitting check


# =============================================================================
# Validation Types
# =============================================================================


@dataclass
class ValidationIssue:
    """A validation issue found."""

    severity: str  # error, warning, info
    message: str
    field: str | None = None


# =============================================================================
# Research Types (for Behavior Architect)
# =============================================================================


@dataclass
class DomainResearchResult:
    """Result of domain research for behavior creation."""

    domain: str
    core_tasks: list[str] = field(default_factory=list)
    suggested_actions: list[dict] = field(default_factory=list)
    suggested_triggers: list[str] = field(default_factory=list)
    constraints: list[str] = field(default_factory=list)
    domain_knowledge: str = ""
    sources: list[str] = field(default_factory=list)

    def to_summary(self) -> str:
        """Get a summary for LLM context."""
        return f"""Domain: {self.domain}

Core Tasks:
{chr(10).join(f'- {t}' for t in self.core_tasks)}

Suggested Actions:
{chr(10).join(f'- {a.get("name", "unknown")}: {a.get("description", "")}' for a in self.suggested_actions)}

Triggers:
{chr(10).join(f'- {t}' for t in self.suggested_triggers)}

Domain Knowledge:
{self.domain_knowledge}
"""


@dataclass
class FailureAnalysis:
    """Analysis of behavior test failures."""

    no_failures: bool = False
    patterns: list[str] = field(default_factory=list)
    root_causes: list[str] = field(default_factory=list)
    suggested_fixes: list[dict] = field(default_factory=list)
